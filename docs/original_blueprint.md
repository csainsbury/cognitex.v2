<chatName="CognitexV2Blueprint"/>

Of course. Your decision to start fresh is a strong one. It allows us to build a clean, modern, and maintainable system based on the new architectural vision without being constrained by the previous implementation.

Overall aim/background: 
the aim was to pull together emails (extracting tasks and actions from emails), meeting transcripts (extracting tasks and actions) calendar and tasks (via api - currently from the app todoist) and intelligently synthesise these - with the aim of identifying the optimal next task but also in helping me identify personal networks and social agendas / opportunities that I might otherwise miss due to my neurodivergence.
I also have the aim of being able to set short/medium/long term goals (prohject foals but also life goals - ie structured and unstructured plans) and have the tool use the resources imported to help guide optimal steps to take toward acheiving the goals

This blueprint outlines an atomic, step-by-step plan to develop Cognitex from a clean Ubuntu 22.04 installation. We will build the application with the "AI agents with tools" paradigm at its core from day one. This plan prioritizes establishing the core architecture, then implementing a single, end-to-end "slice" of functionality (email analysis) to prove the pattern, and finally expanding from there.

---

### Architectural Vision

The system will be a proactive, AI-driven engine. Instead of a user-facing tool for browsing data, it will be an intelligent backend that continuously ingests, analyzes, and synthesizes information. The primary user interface will be an "Insights Dashboard" that presents the *output* of this synthesis: summaries, action plans, draft replies, and social network insights.

**Core Principles:**

1.  **Stateless Tools, Stateful Agents:** Agents will be the long-running "brains" that maintain context and orchestrate tasks. They will use a toolbox of simple, stateless functions to interact with the outside world (Google APIs, etc.).
2.  **Proactive Synthesis Cycle:** A background scheduler will trigger a master `ProactiveSynthesisAgent` every 15-30 minutes. This agent will orchestrate the entire data ingestion and analysis loop.
3.  **Model Ensemble:** A dedicated `AIModelRouter` will select the best LLM for each task (e.g., a fast, cheap model for summarization; a powerful, expensive model for nuanced relationship analysis) to manage cost and performance.
4.  **Insights, Not Raw Data:** The primary data stored and displayed will be the synthesized insights generated by the agents, not the raw emails or calendar events themselves.

---

## Atomic Blueprint for Cognitex v2

### Phase 0: Server & Environment Setup (The Foundation)

This phase prepares the fresh Ubuntu 22.04 server for development.

*   **1. System Preparation**
    *   Update and upgrade system packages: `sudo apt update && sudo apt upgrade -y`
    *   Install Python 3.11 (recommended for modern async features) and pip: `sudo apt install python3.11 python3.11-venv python3-pip -y`
    *   Create a dedicated user for the application to avoid running as root.

*   **2. Project Structure Setup**
    *   Create the project directory: `mkdir ~/cognitex && cd ~/cognitex`
    *   Create the Python virtual environment: `python3.11 -m venv venv`
    *   Activate the environment: `source venv/bin/activate`
    *   Create the core directory structure:
        ```bash
        mkdir -p app/{agents,api,auth,config,database,orchestrator,prompts,services,ui/static,ui/templates}
        touch app/__init__.py app/main.py
        ```

*   **3. Initial Dependencies & Version Control**
    *   Create `requirements.txt` with initial packages:
        ```
        fastapi
        uvicorn[standard]
        pydantic
        pydantic-settings
        python-dotenv
        google-api-python-client
        google-auth-oauthlib
        firebase-admin
        anthropic
        openai
        apscheduler
        ```
    *   Install dependencies: `pip install -r requirements.txt`
    *   Initialize a Git repository: `git init`
    *   Create a `.gitignore` file to exclude `venv/`, `__pycache__/`, `.env`, and other sensitive files.

### Phase 1: Core Application Skeleton

This phase creates a runnable FastAPI application with the basic agent architecture in place.

*   **1. Configuration Management**
    *   **File to Create:** `app/config/settings.py`
    *   **Purpose:** To manage all application settings and secrets using Pydantic's `BaseSettings`.
    *   **Key Code Sections:**
        ```python
        # app/config/settings.py
        from pydantic_settings import BaseSettings
        
        class Settings(BaseSettings):
            APP_ENV: str = "development"
            GOOGLE_CLIENT_ID: str
            # ... other settings for Firebase, AI keys, JWT ...
            
            class Config:
                env_file = ".env"
        
        def get_settings():
            return Settings()
        ```
    *   Create a corresponding `.env` file from a `.env.example` template.

*   **2. Orchestrator and Agent Primitives**
    *   **File to Create:** `app/orchestrator/message.py`, `app/orchestrator/simple_orchestrator.py`
    *   **Purpose:** Define the communication protocol (`Message` class) and a simple, synchronous orchestrator to start with.
    *   **File to Create:** `app/agents/base_agent.py`
    *   **Purpose:** Define the abstract `BaseAgent` class that all other agents will inherit from.

*   **3. Main Application Entrypoint**
    *   **File to Modify:** `app/main.py`
    *   **Purpose:** Set up the FastAPI app, lifespan events for initialization/shutdown, CORS, and a health check endpoint.
    *   **Key Code Sections:**
        ```python
        # app/main.py
        from fastapi import FastAPI
        from contextlib import asynccontextmanager
        
        orchestrator = None

        @asynccontextmanager
        async def lifespan(app: FastAPI):
            global orchestrator
            # Initialize orchestrator, Firebase, register agents...
            yield
            # Shutdown logic
        
        app = FastAPI(lifespan=lifespan)
        
        @app.get("/health")
        def health_check():
            return {"status": "ok"}
        ```

### Phase 2: Authentication & User Management

This phase secures the application and establishes the concept of a user.

*   **1. Firebase Integration**
    *   **File to Create:** `app/database/firebase_client.py`
    *   **Purpose:** To encapsulate all Firestore database interactions.
    *   **Key Methods:** `initialize()`, `get_user()`, `get_or_create_user()`, `update_user()`.

*   **2. Authentication Module**
    *   **Directory to Create:** `app/auth/`
    *   **Files to Create:** `__init__.py`, `models.py`, `auth_handler.py`
    *   **Purpose:** Handle Google OAuth2, JWT creation/verification, and user session management. `auth_handler.py` will contain functions like `authenticate_user` and `get_current_active_user`.

*   **3. Authentication API**
    *   **File to Create:** `app/api/auth_routes.py`
    *   **Purpose:** To expose login endpoints.
    *   **Key Endpoints:** `POST /api/auth/google` for handling the Google Sign-In token. `GET /api/auth/me` to get the current user's profile.

*   **4. Basic Login UI**
    *   **File to Create:** `app/ui/templates/index.html` and `app/ui/static/app.js`
    *   **Purpose:** Create a minimal frontend that shows a "Sign in with Google" button, handles the callback, stores the JWT in `localStorage`, and displays the user's name upon success.

### Phase 3: The First Tool-Based Agent (Email Proof-of-Concept)

This phase implements the core architectural pattern: an agent using LLMs and tools to perform a task.

*   **1. Create the "Toolbox"**
    *   **File to Create:** `app/agents/tools/gmail_tools.py`
    *   **Purpose:** To define simple, stateless Python functions that wrap the Google Gmail API. The docstrings are critical as they are the "API documentation" for the LLM.
    *   **Key Functions:**
        ```python
        # app/agents/tools/gmail_tools.py
        def search_emails(query: str, max_results: int = 10) -> List[Dict]:
            """Searches Gmail for emails matching the query. Use standard Gmail search syntax."""
            pass

        def get_email_details(message_id: str) -> Dict:
            """Retrieves the full body and headers of a specific email by its message ID."""
            pass
        ```
    *   **File to Create:** `app/services/google_api_clients.py`
    *   **Purpose:** To handle the low-level logic of creating authenticated Google API service objects for a given user, including token refresh. The `gmail_tools` will use this service.

*   **2. Create the Reasoning Agent**
    *   **File to Create:** `app/agents/email_agent.py`
    *   **Purpose:** This agent will *not* contain complex sync logic. Its job is to reason about how to fulfill a high-level request using the provided tools.
    *   **Key Methods:**
        ```python
        # app/agents/email_agent.py
        class EmailAgent(BaseAgent):
            async def handle_message(self, message: Message):
                if message.type == "SUMMARIZE_URGENT_EMAILS":
                    prompt = "Find unread emails from my manager and summarize them."
                    tools = [gmail_tools.search_emails, gmail_tools.get_email_details]
                    summary = await self._execute_llm_with_tools(prompt, tools)
                    # ... return summary
            
            async def _execute_llm_with_tools(self, prompt: str, tools: List[callable]) -> Any:
                # This is the core reasoning loop.
                # 1. Send prompt + tool definitions to LLM.
                # 2. LLM responds with a tool call request.
                # 3. Execute the tool function.
                # 4. Send the tool's output back to the LLM.
                # 5. LLM uses the output to generate the final answer.
                # Repeat as necessary.
                pass
        ```

*   **3. API and UI Integration**
    *   **File to Create:** `app/api/email_routes.py`
    *   **Purpose:** Expose an endpoint to trigger the `EmailAgent`.
    *   **Key Endpoint:** `POST /api/email/summarize-urgent`
    *   **UI Update:** Add a button in `index.html` to "Summarize Urgent Emails" which calls this new endpoint and displays the result.

### Phase 4: The Proactive Synthesis Engine

This phase builds the background processing loop that makes Cognitex a proactive assistant.

*   **1. AI Model Router**
    *   **File to Create:** `app/services/ai_model_router.py`
    *   **Purpose:** To abstract model selection. Agents will request a model of a certain "complexity" (e.g., `SIMPLE`, `COMPLEX`), and this router will choose the appropriate, cost-effective model from the available APIs (Claude Haiku, GPT-4o, etc.).

*   **2. The Master Agent**
    *   **File to Create:** `app/agents/proactive_synthesis_agent.py`
    *   **Purpose:** This agent orchestrates the periodic synthesis cycle.
    *   **Key Method:** `_run_synthesis_cycle()`
    *   **Logic:**
        1.  Get the last sync timestamp for each service (Gmail, GCal).
        2.  Send messages to other agents (e.g., `EmailAgent`) asking for *new* information since the last sync.
        3.  Gather all new tasks, events, and commitments.
        4.  Use the `AIModelRouter` with a `COMPLEX` model to synthesize a daily briefing or identify the top 3 priorities.
        5.  Store the generated "insight" in a new Firestore collection.

*   **3. Scheduler Service**
    *   **File to Create:** `app/services/scheduler.py`
    *   **Purpose:** To use `apscheduler` to run the synthesis cycle every 15 minutes.
    *   **Logic:** The scheduler will send a `START_SYNTHESIS_CYCLE` message to the orchestrator, which will be picked up by the `ProactiveSynthesisAgent`.

*   **4. Insights Dashboard**
    *   **Data Structure:** Define the `synthesis_insights` collection in Firestore. An insight document might contain a type (`daily_briefing`, `priority_alert`), content, source data references, and a status (`new`, `viewed`).
    *   **API:** Create `GET /api/insights` to fetch new insights.
    *   **UI:** Refactor `index.html` to be an "Insights Feed" that displays these results, rather than raw task lists.

### Phase 5: Expanding Capabilities

With the core pattern established, adding new functionality becomes modular and repeatable.

*   **1. Add Calendar Agent & Tools:**
    *   Create `app/agents/tools/gcal_tools.py` with functions like `list_events`, `find_free_slots`.
    *   Create `app/agents/calendar_agent.py` that uses these tools to answer questions like "What does my afternoon look like?" or "Find a 30-minute slot for a deep work task."

*   **2. Add Relationship Mapping Agent:**
    *   This agent will be triggered during the synthesis cycle.
    *   It will receive information about new interactions (emails, meetings).
    *   It will use an LLM to analyze the sentiment, reciprocity, and key topics of interactions with specific contacts.
    *   It will update a `relationships` collection in Firestore, tracking the health and status of the user's professional network.

*   **3. Add Goal Agent:**
    *   This agent allows the user to define long-term goals.
    *   During the synthesis cycle, the `ProactiveSynthesisAgent` will provide the `GoalAgent` with the list of new tasks and commitments.
    *   The `GoalAgent` will use an LLM to evaluate how these new items align with the user's stated goals and can generate insights like "This new task directly contributes to your 'Publish Paper' goal."

This blueprint provides a clear, phased path to building a powerful and modern AI-native application, starting from a completely blank slate.